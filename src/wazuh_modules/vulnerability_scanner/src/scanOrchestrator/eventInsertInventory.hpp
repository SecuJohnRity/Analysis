/*
 * Wazuh Vulnerability scanner - Scan Orchestrator
 * Copyright (C) 2015, Wazuh Inc.
 * March 11, 2024.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _EVENT_INSERT_INVENTORY_HPP
#define _EVENT_INSERT_INVENTORY_HPP

#include "chainOfResponsability.hpp"
#include "databaseFeedManager.hpp"
#include "inventorySync.hpp"
#include "scanContext.hpp"

/**
 * @brief TEventInsertInventory class.
 * This class is in charge of inserting the inventory entries for a given agent and affected component type.
 * It receives the scan context and the inventory database and returns the scan context with the inventory updated.
 * The affected component type can be Os or Package.
 * Os: Insert inventory of the OS for the agent.
 * Package: Insert a package into the inventory for the agent.
 *
 * @tparam TScanContext scan context type.
 */
template<typename TScanContext = ScanContext, typename TDatabaseFeedManager = DatabaseFeedManager>
class TEventInsertInventory final
    : public AbstractHandler<std::shared_ptr<TScanContext>>
    , public TInventorySync<TScanContext>
{
private:
    std::shared_ptr<TDatabaseFeedManager> m_databaseFeedManager;

public:
    // LCOV_EXCL_START
    /**
     * @brief EventInsertInventory constructor.
     *
     * @param inventoryDatabase Inventory database.
     */
    explicit TEventInsertInventory(Utils::RocksDBWrapper& inventoryDatabase,
                                   std::shared_ptr<TDatabaseFeedManager>& databaseFeedManager)
        : TInventorySync<TScanContext>(inventoryDatabase)
        , m_databaseFeedManager(databaseFeedManager)
    {
    }
    // LCOV_EXCL_STOP

    /**
     * @brief Handles request and passes control to the next step of the chain.
     *
     * @param data Scan context.
     * @return std::shared_ptr<ScanContext> Abstract handler.
     */
    std::shared_ptr<TScanContext> handleRequest(std::shared_ptr<TScanContext> data) override
    {
        std::string elementKey = data->agentId().compare("000") == 0 && data->clusterStatus()
                                     ? std::string(data->clusterNodeName()) + "_"
                                     : "";
        elementKey.append(data->agentId());
        elementKey.append("_");

        // Create the key for the inventory.
        elementKey.append(TInventorySync<TScanContext>::affectedComponentKey(data));

        std::vector<std::string> insertList;
        std::string insertListString;
        std::string rawCveList;
        const auto& column = AFFECTED_COMPONENT_COLUMNS.at(data->affectedComponentType());

        std::unordered_map<std::string, nlohmann::json> temp_map;
        for (auto it = data->m_elements.begin(); it != data->m_elements.end();)
        {
            auto node = data->m_elements.extract(it++);
            auto offset = m_databaseFeedManager->getCVEOffset(node.key());
            node.key().append("_");
            node.key().append(offset);
            temp_map.insert(std::move(node));
        }

        data->m_elements.merge(temp_map);

        // Build json element for each CVE.
        for (auto& [cve, value] : data->m_elements)
        {
            std::string newElementKey;
            newElementKey.append(elementKey);
            newElementKey.append("_");
            newElementKey.append(cve);

            value = TInventorySync<TScanContext>::buildElement("INSERTED", newElementKey);
        }

        if (TInventorySync<TScanContext>::m_inventoryDatabase.get(elementKey, rawCveList, column))
        {
            auto listCve = Utils::split(rawCveList, ',');
            for (auto& [key, value] : data->m_elements)
            {
                if (std::find(listCve.begin(), listCve.end(), key) == listCve.end())
                {
                    // Concatenate all cves to insert into the inventory.
                    insertListString.append(key);
                    insertListString.append(",");
                }
            }

            if (!insertListString.empty())
            {
                insertListString.append(rawCveList);
                logDebug2(WM_VULNSCAN_LOGTAG,
                          "Updating agent package key: %s -> %s",
                          elementKey.c_str(),
                          insertListString.c_str());
                TInventorySync<TScanContext>::m_inventoryDatabase.put(elementKey, insertListString, column);
            }
        }
        else
        {
            for (auto& [key, value] : data->m_elements)
            {
                // Concatenate all cves to insert into the inventory.
                insertListString.append(key);
                insertListString.append(",");
            }

            if (!insertListString.empty())
            {
                insertListString.pop_back();
                logDebug2(WM_VULNSCAN_LOGTAG,
                          "Inserting agent package key: %s -> %s",
                          elementKey.c_str(),
                          insertListString.c_str());
                TInventorySync<TScanContext>::m_inventoryDatabase.put(elementKey, insertListString, column);
            }
        }

        return AbstractHandler<std::shared_ptr<TScanContext>>::handleRequest(std::move(data));
    }
};

using EventInsertInventory = TEventInsertInventory<>;

#endif // _EVENT_INSERT_INVENTORY_HPP
